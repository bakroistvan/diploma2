% ----------------------------------------------------------------------------
\chapter{A host program bemutatása}
% ----------------------------------------------------------------------------
	A $~100\ \mathrm{FPS}$-el érkező képeket az eszköz globális memóriájának méretét figyelembe véve dolgozom fel.
	A megjelenítésnek nem fontos szigorúan real-time működésűnek lennie (soft real-time), adott fokú késleltetés megengedhető, a
	határidő elmulasztása nem jár súlyos következménynel. A program ciklikusan a következő lépéseket hajtja végre:
	\begin{enumerate*}
		\item Kép fogadása (gyűjtése) a kamerától GigE porton keresztül (beolvasása a host-memóriába),
		\item Képek leküldése a host-memóriájából az eszköz globális memóriájába,
		\item Eszközön futtatandó kernelek inicializálása, argumentumainak beállítása,
		\item Kernelek futtatása az eszközön:
		\begin{enumerate*}
			\item Első kép medián szűrése és az adaptív detektálási szint előállítása,
			\item Az első és a fennmaradó képeken detektálás.
		\end{enumerate*}
		\item Kernelek futása után az eredmény az eszköz globális memóriájából a host-memóriájába való
		visszatöltése,
		\item Posztprocesszálás, OpenGL megjelenítés.
	\end{enumerate*}
	A kernel megírása során a korábbi \ref{sec:opencl}. fejezetben említetteket figyelembe kell venni.
	Főként a véges lokális és globális memóriát és a work-itemek számát. A kernelek adat-parallel módon lett megírva.
	
\section{A host program párhuzamos felépítése}
	A korbábban kitűzött késleltetéssel rendelkező, de a real-time viselkedésre több tényező rossz hatással van.
	Ezek a következők:
	\begin{itemize}
	  \item A kamera GigE interfészének jittere,
	  \item Operációs rendszer által futtatott további folyamatok,
	  \item Feldolgozó (szűrő és detektáló) algoritmus futási idejének (ET = execution time) változatossága. 
	\end{itemize}
	A kernelek közül a medián szűrő, ami elrontja a fix futási időt (Fix E. T.) és abba sztochasztikát visz.
	A változó futási időről elmondható, hogy a bemeneti kép értékeitől függ. Pontosabban a medián szűrő ablakain belül található
	pixelek rendezettségétől.
	A medián számításának worst case execeution time-ja (WCET), pontosabban wc. lépésszáma ismert alogoritmuselméletből, ami korlátos
	és megegyezik - a bemenet $N$ számossága esetén - a $O(N \log N)$ \todo{fel lehet javítani\ldots} értékkel.
	
	Adódik, hogy a host programot több konkurens szálra bontva kerüljön implementálásra az ismert Producer-Consumer
	\cite{EWD:EWD329pub} mintát alkalmazva.
	\cbstart
	A szálak létrehozását és kezelését a \textit{Boost C++ Libraries} \cite{boost} keretrendszer
	megfelelő függvényhívásai oldják meg. A keretrendszer parancssori argumentumkezelést, szálkezelést, szemafort, várakozási
	listát és atomi működésű operátorokkal rendelkező változókat nyújt a programozó számára.
	\cbend
	A szálak közötti adatkapcsolást FIFO típusú (single producer - single consumer) várakozási listával oldom meg.
	
	Egy producer szálon kerül implementálásra a kamera képeinek fogadása és a várakozási sorba állítása. Következő consumer
	és egyben producer szálon a várakozási sorból egy kép elővétele majd feldolgozására kerül sor az OpenCL kernel által, aminek
	eredménye a megjelenítő OpenGL bufferébe kerül letárolásra. Az utolsó consumer szál az OpenGL-es megjelenítést végzi.
	Az implementálandó szálak ``szekvencia diagrammja'' a következő \ref{fig:host_seq} ábrán látható. 
	

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[!htp]
	
	\begin{sequencediagram}
	%\newthread{m}{\makebox[2cm]{Main}}
	\newthread{m}{Main}
	\newinst{prod}{\makebox[2cm]{Producer}}
	\tikzstyle{inststyle}+=[left color = green, right color = red, rounded corners=3mm]
	\newinst[2]{ocl}{OpenCL}
	
	\tikzstyle{inststyle}+=[left color = white, right color = white]
	%\newthread{cons}{\makebox[2cm]{Consumer}}
	\newinst{cons}{Consumer}
	\tikzstyle{inststyle}+=[left color = blue, right color = blue, rounded corners=3mm]
	\newinst[1.5]{ogl}{OpenGL}
	
		\begin{call}{m}{start()}{cons}{}
		
		%\prelevel
		
		\begin{call}{m}{start()}{prod}{}
			\begin{call}{prod}{enqueueKernel()}{ocl}{ReadBuffer()}
			\end{call}
			
			\begin{messcall}{cons}{start()}{ogl}
			\begin{sdblock}{glutMainLoop()}{}
				\begin{call}{cons}{}{cons}{}
				\end{call}
			\end{sdblock}
			
			\mess{prod}{buff[][]}{ogl}
			
			\begin{call}{ogl}{glutSwapBuffers()}{ogl}{}
			\end{call}
			\end{messcall}
					
		\end{call}
		
		
		\end{call}
	\end{sequencediagram}


  \caption{Host program szekvencia diagrammja}
  \label{fig:host_seq}  
\end{figure}


\section{\texttt{main} (producer) szál}
\dots
\subsection{Inicializálás}
A korábban említett várakozási lista fix méretű a $100\ \mathrm{FPS}$-el érkező képek $1$ másodpercnyi feldolgozásához szükséges
méretű.
\subsection{Kamera adatfolyamának fogadása}
\ldots

\section{Producer szál}
\dots
\subsection{OpenCL inicializálás}
\begin{itemize}
	\item Infó lekérdezése
	\item Global mem. méret
	\item Local mem. méret
\end{itemize}

\subsection{Kép kernelekkel történő feldolgozása}
\ldots

\section{Consumer szál}
\dots
\subsection{OpenGL inicializáció}
\ldots

\subsection{OpenGL callback függvény}
\dots
